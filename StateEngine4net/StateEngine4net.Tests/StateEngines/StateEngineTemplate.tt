<#@ template debug="false" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#


    var parentFolder = Host. ResolvePath("../");
    List<string> allEngineDescriptors = Directory.GetFiles(parentFolder, "*.StateEngine", SearchOption.AllDirectories).ToList();
    foreach (
        var file in
            allEngineDescriptors.Select(
                f => (
                    inFile: f, 
                    outDir: new FileInfo(f).DirectoryName))
                .ToList())
    {

        List<string> states = new List<string>();

        List<(string from, string transitionOnSuccess, string onTransitioning, string stateOnSuccess,
                           string transitionOnFailed , string onTransitionFailed, string stateOnFailed)> Transitions
            = new List<(string from, string transitionOnSuccess, string onTransitioning, string stateOnSuccess,
                string transitionOnFailed , string onTransitionFailed, string stateOnFailed)>();

        string entity = "";
        string entityNamespace = "";

        string seNamespace = "";


        List<string> lines = File.ReadAllLines(file.inFile).Select(l => l.Replace(" ", "")).ToList();

        // read entity name
        var entityLine = lines.FirstOrDefault(l => l.StartsWith("Entity:"));
        if (!string.IsNullOrWhiteSpace(entityLine))
        {
            entity = entityLine.Split(':').Last().Trim();
        }

        // read states
        var statesLine = lines.FirstOrDefault(l => l.StartsWith("States:"));
        if (!string.IsNullOrWhiteSpace(statesLine))
        {
            states =
                statesLine.Split(':')[1].Split(',').Select(x => x.Trim()).Distinct()
                    .ToList();
        }

        // read transitions
        var transitionLines = lines.Where(l => l.StartsWith("T:"));
        Regex r = new Regex(@"\s*(?<fromState>\w+)\s*(\+\s*(?<transitionOnSuccess>\w+))\s*(\|\s*(?<onTransitioning>\w*))?\s*>\s*(?<stateOnSuccess>\w+)\s*((\-\s*(?<transitionOnFailed>\w+))\s*(\|\s*(?<onTransitionFailed>\w*))?\s*>\s*(?<stateOnFailed>\w+))?");
        foreach (var transitionLine in transitionLines)
        {
            Match m = r.Match(transitionLine);
            if (m.Success)
            {
                Transitions.Add(
                    (
                        m.Groups["fromState"].Value.Trim(), 
                        m.Groups["transitionOnSuccess"].Value.Trim(), 
                        m.Groups["onTransitioning"].Value.Trim(),
                        m.Groups["stateOnSuccess"].Value.Trim(), 
                        m.Groups["transitionOnFailed"].Value.Trim(), 
                        m.Groups["onTransitionFailed"].Value.Trim(),
                        m.Groups["stateOnFailed"].Value.Trim()
                    ));
            }
        }

        if (string.IsNullOrWhiteSpace(entity) || !states.Any() || !Transitions.Any())
        {
#>
// ERROR: StateEngine Description '<#= file.inFile #>' is invalid!         
<#
    continue;
        }

        var entityFile = Directory.GetFiles(parentFolder, $"{entity}.cs", SearchOption.AllDirectories);
        if (entityFile.Length != 1)
        {
#>
// ERROR: Entity-File '<#= $"{entity}.cs" #>' was not found!
<#
    continue;
        }
        else
        {
            entityNamespace = File.ReadAllLines(entityFile[0]).Where(l => l.StartsWith("namespace")).FirstOrDefault();
            if (string.IsNullOrWhiteSpace(entityNamespace))
            {
#>
// ERROR: Namespace Definition in Entity-File '<#= $"{entity}.cs" #>' was not found!
<#
    continue;
            }
            else
            {
                var seNamespaceParts = entityNamespace.Split('.');
                seNamespace = string.Join(".",
                    seNamespaceParts.Take(seNamespaceParts.Length - 1).Union(new[] {"StateEngine"}));
            }
        }

#>
//  <autogenerated>
//
//      This file was generated by T4 code generator 'StateEngineTemplate.tt'
//
//      Any changes made to this file manually will be lostnext time the file is regenerated.
//
//      As all classes are created as partial classes you can extend these classes by 
//      creating and adapting a matching partial class.
//
//</autogenerated>

using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using StateEngine4net.Shared;
using StateEngine4net.Shared.Exceptions;
using StateEngine4net.Shared.Interfaces;
using Newtonsoft.Json;
using <#= entityNamespace.Substring(9).Trim() #>;

<#= seNamespace #>
{
<#
        /// prepare values
        var transitionNames = 
            Transitions
                .Select(t => t.transitionOnSuccess)
                .Union(Transitions.Select(t => t.transitionOnFailed))
                .Where(t => !t.Equals("TechnicalError", StringComparison.InvariantCultureIgnoreCase)
                                && !string.IsNullOrWhiteSpace(t))
                .Distinct()
                .ToList();

#>
    public interface I<#= entity #>State : IState<I<#= entity #>State, <#= entity #>StatesEnum>
    {
<#
        foreach (var t in transitionNames)
        {
#>
        I<#= entity #>State <#= t #>();
<#
        }
#>      
    }

    public abstract class <#= entity #>State : State<I<#= entity #>State, <#= entity #>StatesEnum>, I<#= entity #>State
    {
<#
        foreach (var t in transitionNames)
        {
#>
        public virtual I<#= entity #>State <#= t #>() => UndefinedTransition(nameof(<#= t #>));
<#
        }
#>
        public override I<#= entity #>State TechnicalError() => new <#= entity #>States.TechnicalError();

    }
     
    [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public enum <#= entity #>StatesEnum 
    {
        <#= string.Join(", ", states) #>
    }

    public class <#= entity #>States
    {
<#
        foreach (var s in states)
        {
#>
        public class <#= s #> : <#= entity #>State, IState<I<#= entity #>State, <#= entity #>StatesEnum>
        {
            public override <#= entity#>StatesEnum Name => <#= entity#>StatesEnum.<#= s#>;
<#
            var stateTransitions = Transitions.Where(t => t.from == s).ToList();
            var generateTransitions =
                stateTransitions.Where(
                    t =>
                        !string.IsNullOrWhiteSpace(t.transitionOnSuccess) &&
                        !string.IsNullOrWhiteSpace(t.stateOnSuccess)).Select(
                            t => (transition: t.transitionOnSuccess, state: t.stateOnSuccess))
                    .Union(
                        stateTransitions.Where(
                            t =>
                                !string.IsNullOrWhiteSpace(t.transitionOnFailed) &&
                                !string.IsNullOrWhiteSpace(t.stateOnFailed)).Select(
                                    t => (transition: t.transitionOnFailed, state: t.stateOnFailed)));
        foreach (var t in generateTransitions)
        {
#>
            public override I<#= entity #>State <#= t.transition #>() => new <#= entity #>States.<#= t.state #>();       
<#
        }
#>
        }

<#
        }
#>
 
    }

    public interface I<#= entity #>StateEngine : IStateEngine<<#= entity #>, I<#= entity #>State, <#= entity#>StatesEnum> { }

    /// <summary>
    /// 	RunStateController provides Actions that are to be executed on 
    /// 	state transitions. This allows modifications and interactions in
    /// 	and of the stated object when the state is about to change.
    /// </summary>
    public abstract class <#= entity #>StateEngineBase : StateEngine<<#= entity #>, I<#= entity #>State, <#= entity#>StatesEnum>, I<#= entity #>StateEngine
    {

        public override List<Transition<<#= entity #>, I<#= entity #>State, <#= entity#>StatesEnum>> Transitions 
            => new List<Transition<<#= entity #>, I<#= entity #>State, <#= entity#>StatesEnum>>
            {
<#
        foreach (var t in Transitions)
        {
#>
                new Transition<<#= entity #>, I<#= entity #>State, <#= entity#>StatesEnum>(new <#= entity #>States.<#= t.from #>(), state => state.<#= t.transitionOnSuccess #>(), <#= 
                        string.IsNullOrWhiteSpace(t.onTransitioning) ? "null" : t.onTransitioning #>, <#= 
                        string.IsNullOrWhiteSpace(t.transitionOnFailed) ? "null" : $"state => state.{t.transitionOnFailed}()" #>,<#= 
                        string.IsNullOrWhiteSpace(t.onTransitionFailed) ? "null" : t.onTransitionFailed #>),
<#
        }
#>
            };

        // NOTE: if a constructor receiving specific dependencies is required, 
        //       defining the required constructor with all required dependencies 
        //       to handle the transitions, e. g. repositories, logger, etc.
        //       in the file <#= entity #>StateEngine.Partial.cs file
        //
        //       implement the following methods as partial methods in that partial 
        //       class as well in order to satisfy the MethodGroup-Calls in the
        //       transition list above
<#
        List<string> transitionActions =
            Transitions
                .Where(x => !string.IsNullOrWhiteSpace(x.onTransitioning))
                .Select(x => x.onTransitioning)
                .Union(
                    Transitions
                        .Where(x => !string.IsNullOrWhiteSpace(x.onTransitionFailed))
                        .Select(x => x.onTransitionFailed))
                .Distinct()
                .ToList();


        foreach (var t in transitionActions)
        {
#>
        protected abstract Task<bool> <#= t #>(<#= entity #> <#= entity.ToLower() #>);
<#
        }
#>
    }
} 
<#
        SaveFile(file.outDir, $"{entity}.StateEngine.Generated.cs", this.GenerationEnvironment.ToString());
        this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
        string engineFile = Path.Combine(file.outDir, $"{entity}.StateEngine.Partial.cs");
        // NOTE >>> skip generation of partial file to allow
        //          developers to place a class inheriting the
        //          StateEngineBase-class (see above) wherever
        //          they want
        if (File.Exists(engineFile))
            continue;
#>  
//  <autogenerated> 
//
//      This file was generated by T4 code generator 'StateEngineTamplate.tt'
//
//      Any changes made to this file manually will be PERSISTED.
//
//      This file will NOT be OVERWRITTEN at the next generation.
//      
//      Partial methods for new actions will have to be added manually.
//
//</autogenerated>
using System;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Threading.Tasks;
using StateEngine4net.Shared;
using StateEngine4net.Shared.Exceptions;
using StateEngine4net.Shared.Interfaces;
using <#= entityNamespace.Substring(9).Trim() #>;

<#= seNamespace #>
{
    /// <summary>
    /// 	The RunStateController provides Actions that are to be executed on 
    /// 	state transitions. This allows modifications and interactions in
    /// 	and of the stated object when the state is about to change.
    /// </summary>
    public class <#= entity #>StateEngine : <#= entity #>StateEngineBase, I<#= entity #>StateEngine
    {
        // NOTE: use the following constructor in this partial specific dependencies are required
        //       in order to handle transitions, e. g. repositories, logger, etc.
        public <#= entity #>StateEngine(/* add dependencies here */)
        {
        }

        // NOTE: implement the following partial methods in order to process the entities
        //       in accordance to the corresponding transitions
<#
        foreach (var t in transitionActions)
        {
#>
        protected override async Task<bool> <#= t #>(<#= entity #> <#= entity.ToLower() #>)
        {
            /* add logic here */
            await Task.Delay(0).ConfigureAwait(false);
            return true;
        }
<#
        }
#>
    }
}
<#
        SaveFile(file.outDir, engineFile, this.GenerationEnvironment.ToString());
        this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
    }
#> 
<#+
    public void SaveFile(string folder, string fileName, string content)
    {
        string engineFile = Path.Combine(folder, fileName);
        using(FileStream fs = new FileStream(Path.Combine(folder, engineFile.Trim()), FileMode.Create))
        using (StreamWriter str = new StreamWriter(fs))
        {
            str.WriteLine(content);
            str.Flush();
        }
    }
#>
