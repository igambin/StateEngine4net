<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ assembly name = "EnvDTE" #><# /* This assembly provides access to Visual Studio project properties */ #>
<#
    string parentFolder = GetSolutionDirectory();
    List<string> allEngineDescriptors = Directory.GetFiles(parentFolder, "*.StateEngine", SearchOption.AllDirectories).ToList();
    foreach (
        var file in
            allEngineDescriptors.Select(
                f => (
                    inFile: f, 
                        outDir: new FileInfo(f).DirectoryName))
                .ToList())
    {
        List<string> states = new List<string>();

        List<(string from, string transitionOnSuccess, string onTransitioning, string stateOnSuccess,
            string transitionOnFailed , string onTransitionFailed, string stateOnFailed)> Transitions
                = new List<(string from, string transitionOnSuccess, string onTransitioning, string stateOnSuccess,
                    string transitionOnFailed , string onTransitionFailed, string stateOnFailed)>();

        string entity = "";
        string entityNamespace = "";

        string seNamespace = "";


        List<string> lines = File.ReadAllLines(file.inFile).Select(l => l.Replace(" ", "")).ToList();

        // read entity name
        var entityLine = lines.FirstOrDefault(l => l.StartsWith("Entity:"));
        if (!string.IsNullOrWhiteSpace(entityLine))
        {
            entity = entityLine.Split(':').Last().Trim();
        }

        // read states
        var statesLine = lines.FirstOrDefault(l => l.StartsWith("States:"));
        if (!string.IsNullOrWhiteSpace(statesLine))
        {
            states =
                statesLine.Split(':')[1].Split(',').Select(x => x.Trim()).Distinct()
                    .ToList();
        }

        // read transitions
        var transitionLines = lines.Where(l => l.StartsWith("T:"));
        Regex r =
            new Regex(
                @"\s*(?<fromState>\w+)\s*(\+\s*(?<transitionOnSuccess>\w+))\s*(\|\s*(?<onTransitioning>\w*))?\s*>\s*(?<stateOnSuccess>\w+)\s*((\-\s*(?<transitionOnFailed>\w+))\s*(\|\s*(?<onTransitionFailed>\w*))?\s*>\s*(?<stateOnFailed>\w+))?");
        foreach (var transitionLine in transitionLines)
        {
            Match m = r.Match(transitionLine);
            if (m.Success)
            {
                Transitions.Add(
                    (
                        m.Groups["fromState"].Value.Trim(), 
                        m.Groups["transitionOnSuccess"].Value.Trim(), 
                        m.Groups["onTransitioning"].Value.Trim(),
                        m.Groups["stateOnSuccess"].Value.Trim(), 
                        m.Groups["transitionOnFailed"].Value.Trim(), 
                        m.Groups["onTransitionFailed"].Value.Trim(),
                        m.Groups["stateOnFailed"].Value.Trim()
                    ));
            }
        }

        if (string.IsNullOrWhiteSpace(entity) || !states.Any() || !Transitions.Any())
        {
#>
// ERROR: StateEngine Description '<#= file.inFile #>' is invalid!         
<#
            continue;
        }

        var entityFile = Directory.GetFiles(parentFolder, $"{entity}.cs", SearchOption.AllDirectories);
        if (entityFile.Length != 1)
        {
#>
// ERROR: Entity-File '<#= $"{entity}.cs" #>' was not found!
<#
            continue;
        }
        else
        {
            entityNamespace = File.ReadAllLines(entityFile[0]).Where(l => l.StartsWith("namespace")).FirstOrDefault();
            if (string.IsNullOrWhiteSpace(entityNamespace))
            {
#>
// ERROR: Namespace Definition in Entity-File '<#= $"{entity}.cs" #>' was not found!
<#
                continue;
            }

            seNamespace = GetStateEngineNamespace(file.outDir);

        }

#>
//  <autogenerated>
//
//      This file was generated by T4 code generator 'StateEngineTamplate.tt'
//
//      Any changes made to this file manually will be lostnext time the file is regenerated.
//
//      As all classes are created as partial classes you can extend these classes by 
//      creating and adapting a matching partial class.
//
//</autogenerated>

using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.Threading.Tasks;
using StateEngine4net.Core;
using StateEngine4net.Core.Exceptions;
using StateEngine4net.Core.Interfaces;
using StateEngine4net.Core.IoC;
using StateEngine4net.Core.Models;
using StateEngine4net.Events;
using StateEngine4net.Events.Interfaces;
using LightInject;
using Newtonsoft.Json;
using <#= entityNamespace.Substring(9).Trim() #>;
using <#= seNamespace #>.TransitionHandlers;

namespace <#= seNamespace #>
{
<#
        /// prepare values
        var transitionNames =
            Transitions
                .Select(t => t.transitionOnSuccess)
                .Union(Transitions.Select(t => t.transitionOnFailed))
                .Where(t => !string.IsNullOrWhiteSpace(t))
                .Distinct()
                .ToList();

#>
    [GeneratedCode("<#= TemplateName() #>", "<#= TemplateVersion()#>")]
    public interface I<#= entity #>State : IState<I<#= entity #>State, <#= entity #>StatesEnum>
    {
<#
        foreach (var t in transitionNames)
        {
#>
        I<#= entity #>State <#= t #>();
<#
        }
#>      
    }

    [GeneratedCode("<#= TemplateName() #>", "<#= TemplateVersion()#>")]
    public abstract class <#= entity #>State : State<I<#= entity #>State, <#= entity #>StatesEnum>, I<#= entity #>State
    {
<#
        foreach (var t in transitionNames)
        {
#>
        public virtual I<#= entity #>State <#= t #>() => UndefinedTransition(nameof(<#= t #>));
<#
        }
#>
    }
     
    [GeneratedCode("<#= TemplateName() #>", "<#= TemplateVersion()#>")]
    [Newtonsoft.Json.JsonConverter(typeof(Newtonsoft.Json.Converters.StringEnumConverter))]
    [System.Text.Json.Serialization.JsonConverter(typeof(System.Text.Json.Serialization.JsonStringEnumConverter))]
    public enum <#= entity #>StatesEnum 
    {
        <#= string.Join(", ", states) #>
    }

    [GeneratedCode("<#= TemplateName() #>", "<#= TemplateVersion()#>")]
    public class <#= entity #>States
    {
<#
        foreach (var s in states)
        {
#>
        public class <#= s #> : <#= entity #>State, IState<I<#= entity #>State, <#= entity #>StatesEnum>
        {
            public override <#= entity #>StatesEnum Name => <#= entity #>StatesEnum.<#= s #>;
<#
            var stateTransitions = Transitions.Where(t => t.from == s).ToList();
            var generateTransitions =
                stateTransitions.Where(
                    t =>
                        !string.IsNullOrWhiteSpace(t.transitionOnSuccess) &&
                        !string.IsNullOrWhiteSpace(t.stateOnSuccess)).Select(
                            t => (transition: t.transitionOnSuccess, state: t.stateOnSuccess));

            foreach (var t in generateTransitions)
            {
#>
            public override I<#= entity #>State <#= t.transition #>() => new <#= entity #>States.<#= t.state #>();       
<#
            }
#>
        }

<#
        }
#>
    }

    [GeneratedCode("<#= TemplateName() #>", "<#= TemplateVersion()#>")]
    public interface I<#= entity #>StateEngine : IStateEngine<<#= entity #>, I<#= entity #>State, <#= entity #>StatesEnum> { }
<#
        var transitionActions =
            Transitions
                .Where(x => !string.IsNullOrWhiteSpace(x.onTransitioning))
                .Select(x => x.onTransitioning)
                .Union(
                    Transitions
                        .Where(x => !string.IsNullOrWhiteSpace(x.onTransitionFailed))
                        .Select(x => x.onTransitionFailed))
                .Distinct()
                .ToList();

        // create interfaces
        var interfaces = string.Join("\r\n\r\n\t",
            transitionActions.Select(t => $"[GeneratedCode(\"{TemplateName()}\", \"{TemplateVersion()}\")]\r\n\tpublic interface I{entity}{t}Handler : IStateHandler<{entity}> {{ }}"));
#>   
    <#= interfaces #>

    /// <summary>
    /// 	RunStateController provides Actions that are to be executed on 
    /// 	state transitions. This allows modifications and interactions in
    /// 	and of the stated object when the state is about to change.
    /// </summary>
    [GeneratedCode("<#= TemplateName() #>", "<#= TemplateVersion()#>")]
    public class <#= entity #>StateEngine : StateEngine<<#= entity #>, I<#= entity #>State, <#= entity #>StatesEnum>, I<#= entity #>StateEngine
    {

        public override List<TransitionDefinition<<#= entity #>, I<#= entity #>State, <#= entity #>StatesEnum>> Transitions 
            => new List<TransitionDefinition<<#= entity #>, I<#= entity #>State, <#= entity #>StatesEnum>>
            {
<#
        foreach (var t in Transitions)
        {
#>
                new TransitionDefinition<<#= entity #>, I<#= entity #>State, <#= entity #>StatesEnum>(new <#= entity #>States.<#= t.from #>(), state => state.<#= t.transitionOnSuccess #>(), <#=
                string.IsNullOrWhiteSpace(t.onTransitioning) ? "null" : t.onTransitioning #>, <#=
                string.IsNullOrWhiteSpace(t.transitionOnFailed) ? "null" : $"state => state.{t.transitionOnFailed}()" #>,<#=
                string.IsNullOrWhiteSpace(t.onTransitionFailed) ? "null" : t.onTransitionFailed #>),
<#
        }
#>
            };
<#
        // create properties
        var props = string.Join("\r\n\t\t",
            transitionActions.Select(t => $"private I{entity}{t}Handler {entity}{t}Handler {{ get; }}"));
#>
    
        <#= props #>
<#

        // create constructor arguments
        var args = "\r\n\t\t\t" +
                   string.Join(",\r\n\t\t\t",
                       transitionActions.Select(
                           t =>
                               $"I{entity}{t}Handler {entity[0].ToString().ToLowerInvariant()}{string.Join("", entity.Skip(1))}{t}Handler"));
#>

        public <#= entity #>StateEngine(            <#= args #>,
<#
#>
            IStateEventBus<StateChangedEvent<<#= entity #>>> stateEventBus
        ) : base(stateEventBus)
        {
<#
        // create properties
        var assignments = "\t" +
                          string.Join("\r\n\t\t\t",
                              transitionActions.Select(
                                  t =>
                                      $"{entity}{t}Handler = {entity[0].ToString().ToLowerInvariant()}{string.Join("", entity.Skip(1))}{t}Handler;"));
#>
        <#= assignments #>
        }

<#
        // => ReportingTaskOnInitHandler.ExecuteTransition((reportingtask));
        foreach (var t in transitionActions)
        {
#>
        protected IStateHandler<<#= entity #>>  <#= t #>() => <#= entity #><#= t #>Handler;
<#
        }
#>
    }

    [GeneratedCode("<#= TemplateName() #>", "<#= TemplateVersion()#>")]
    public sealed class <#= entity #>StateEngineDependencyRegistration : IDependencyRegistration
    {
        public void RegisterDependencies(IServiceContainer serviceContainer)
        {
            if (serviceContainer == null) throw new ArgumentNullException(nameof(serviceContainer));
            Compose(serviceContainer);
        }

        public void Compose(IServiceRegistry serviceRegistry)
        {
            serviceRegistry.Register<I<#= entity #>StateEngine, <#= entity #>StateEngine>(new PerContainerLifetime());
<#
        // create interfaces
        var depRegistrations = string.Join("\r\n\t\t\t",
            transitionActions.Select(
                t => $"serviceRegistry.Register<I{entity}{t}Handler, {entity}{t}Handler>(new PerContainerLifetime());"));
#>            <#= depRegistrations #>
            serviceRegistry.RegisterDomainEvent<StateChangedEvent<<#= entity #>>>();

        }
    }
    
} 
<#
        SaveFile(file.outDir, $"{entity}.StateEngine.Generated.cs", this.GenerationEnvironment.ToString());
        this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);

        string transitionFileDir = Path.Combine(file.outDir, "TransitionHandlers");
        foreach (var t in transitionActions)
        {
            
            string transitionHandlerFile = Path.Combine(transitionFileDir, $"{entity}{t}Handler.cs");
            if (File.Exists(transitionHandlerFile)) continue;
#>  
//  <autogenerated>
//
//      This file was generated by T4 code generator 'StateEngineTamplate.tt'
//      Any changes made to this file manually will be PERSISTED.
//      This file will NOT be OVERWRITTEN at the next generation.
//      Partial methods for new actions will have to be added manually.
//
//</autogenerated>
using System;
using System.CodeDom.Compiler;
using System.Collections.Generic;
using System.Linq.Expressions;
using System.Threading.Tasks;
using StateEngine4net.Shared.StateEngine;
using StateEngine4net.Shared.StateEngine.Exceptions;
using StateEngine4net.Shared.StateEngine.Interfaces;
using StateEngine4net.Shared.EventBus;
using StateEngine4net.Shared.EventBus.Interfaces;
using <#= entityNamespace.Substring(9).Trim() #>;

namespace <#= seNamespace #>.TransitionHandlers
{
    /// <summary>
    ///
    /// 	This TransitionHandler provides the action that is to be executed
    /// 	for the state transition <#= t #>. This allows 
    ///     modifications and interactions in and of the stated object when 
    ///     its state is about to change.
    ///
    /// </summary>
    [GeneratedCode("<#= TemplateName() #>", "<#= TemplateVersion()#>")]
    public class <#= entity #><#= t #>Handler : I<#= entity #><#= t #>Handler
//  optionally uncomment any of these to implement: 
//                                              ,IPrevalidation<<#= entity #>>
//                                              ,IBeforeTransition<<#= entity #>>
//                                              ,IAfterSuccessfulTransition<<#= entity #>> 
//                                              ,IAfterFailedTransition<<#= entity #>>
    {

        // NOTE: add specific dependencies here as private properties and 
        //       then use the following constructor in order to inject according
        //       interfaces in order to handle the specified transition
        //       e. g. repositories, logger, integrations, etc.
        public <#= entity #><#= t #>Handler(/* add dependencies here */)
        {
        }

        public async Task<ITransitionExecutionResult> ExecuteTransition(<#= entity #> statedEntity)        
        {
            await Task.Delay(0); // dummy to avoid await-warning CS1998

            if (false /* anything goes wrong */ )
            {
                var failedResult = new TransitionFailed
                {
                    MessageKey = "errorMessageKey"
                };
                failedResult.AddMessageArg("key1", "value1")
                            .AddMessageArg("key2", "value2");
                return failedResult;
            }
            return new TransitionSuccessful();
        }
    }
}
<#
            SaveFile(transitionFileDir, transitionHandlerFile, this.GenerationEnvironment.ToString());
            this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
        }
    }
#> 
<#+
    private static string SolutionFile() => "StateEngine4Net.sln";
    private static string TemplateName() => "StateEngineTemplate.tt";
    private static string TemplateVersion() => "1.0.0.0";

    public void SaveFile(string folder, string fileName, string content)
    {
        string engineFile = Path.Combine(folder, fileName);
        if (!Directory.Exists(folder)) Directory.CreateDirectory(folder);
        using(FileStream fs = new FileStream(Path.Combine(folder, engineFile.Trim()), FileMode.Create))
        using (StreamWriter str = new StreamWriter(fs))
        {
            str.WriteLine(content);
            str.Flush();
        }
    }
    public string GetSolutionDirectory()
    {
        var sp = Host as IServiceProvider;
        var dte = sp.GetService(typeof(EnvDTE.DTE)) as EnvDTE.DTE;
        return Path.GetDirectoryName(dte.Solution.FullName);
    }

    public string GetStateEngineNamespace(string outDir)
    {
        var projects = File
                .ReadLines(Path.Combine(GetSolutionDirectory(), SolutionFile()))
                .Where(x => x.StartsWith("Project", StringComparison.OrdinalIgnoreCase))
                .Where((x => x.Contains(".csproj\"")))
                .Select(x =>
                {
                    var chunks =
                        x.Split(' ', '=')
                            .Where(c => !string.IsNullOrWhiteSpace(c))
                            .Select(c => c.Trim(new[] {' ', ',', '"'})).ToArray();
                    var nameSpace = chunks[1];
                    var projFile = Path.Combine(GetSolutionDirectory(), chunks[2]);
                    var projFolder = new FileInfo(projFile).DirectoryName;

                    return (name: nameSpace, folder: projFolder);

                });
        var proj = projects.FirstOrDefault(p => outDir.StartsWith(p.folder));
        var nsItems = new List<string>();
        nsItems.Add(proj.name); 
        nsItems.AddRange(outDir.Substring(Path.Combine(GetSolutionDirectory(), proj.folder).Length).Split('\\').Where(x => !string.IsNullOrWhiteSpace(x)));
        return string.Join(".", nsItems);
    }
/* Never save this file with a blank line after the following
 * closing #-tag, CodeGeneration will fail is there is
 * anything after the >
 **/
#>