<#@ template debug="false" hostspecific="true" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#


    var parentFolder = Host.ResolvePath("../");
    List<string> allEngineDescriptors = Directory.GetFiles(parentFolder, "*.StateEngine", SearchOption.AllDirectories).ToList();
    foreach (
        var file in
            allEngineDescriptors.Select(
                f => (
                    inFile: f, 
                    outDir: new FileInfo(f).DirectoryName))
                .ToList())
    {

        List<string> states = new List<string>();

        List<(string from, string transitionOnSuccess, string onTransitioning, string stateOnSuccess,
                           string transitionOnFailed , string onTransitionFailed, string stateOnFailed)> Transitions
            = new List<(string from, string transitionOnSuccess, string onTransitioning, string stateOnSuccess,
                string transitionOnFailed , string onTransitionFailed, string stateOnFailed)>();

        string entity = "";
        string entityNamespace = "";

        string seNamespace = "";


        List<string> lines = File.ReadAllLines(file.inFile).Select(l => l.Replace(" ", "")).ToList();

        // read entity name
        var entityLine = lines.FirstOrDefault(l => l.StartsWith("Entity:"));
        if (!string.IsNullOrWhiteSpace(entityLine))
        {
            entity = entityLine.Split(':').Last().Trim();
        }

        // read states
        var statesLine = lines.FirstOrDefault(l => l.StartsWith("States:"));
        if (!string.IsNullOrWhiteSpace(statesLine))
        {
            states =
                statesLine.Split(':')[1].Split(',').Select(x => x.Trim()).Distinct()
                    .ToList();
        }

        // read transitions
        var transitionLines = lines.Where(l => l.StartsWith("T:"));
        Regex r = new Regex(@"\s*(?<fromState>\w+)\s*(\+\s*(?<transitionOnSuccess>\w+))\s*(\|\s*(?<onTransitioning>\w*))?\s*>\s*(?<stateOnSuccess>\w+)\s*((\-\s*(?<transitionOnFailed>\w+))\s*(\|\s*(?<onTransitionFailed>\w*))?\s*>\s*(?<stateOnFailed>\w+))?");
        foreach (var transitionLine in transitionLines)
        {
            Match m = r.Match(transitionLine);
            if (m.Success)
            {
                Transitions.Add(
                    (
                        m.Groups["fromState"].Value.Trim(), 
                        m.Groups["transitionOnSuccess"].Value.Trim(), 
                        m.Groups["onTransitioning"].Value.Trim(),
                        m.Groups["stateOnSuccess"].Value.Trim(), 
                        m.Groups["transitionOnFailed"].Value.Trim(), 
                        m.Groups["onTransitionFailed"].Value.Trim(),
                        m.Groups["stateOnFailed"].Value.Trim()
                    ));
            }
        }

        if (string.IsNullOrWhiteSpace(entity) || !states.Any() || !Transitions.Any())
        {
#>
// ERROR: StateEngine Description '<#= file.inFile #>' is invalid!         
<#
    continue;
        }

        var entityFile = Directory.GetFiles(parentFolder, $"{entity}.cs", SearchOption.AllDirectories);
        if (entityFile.Length != 1)
        {
#>
// ERROR: Entity-File '<#= $"{entity}.cs" #>' was not found!
<#
    continue;
        }
        else
        {
            entityNamespace = File.ReadAllLines(entityFile[0]).Where(l => l.StartsWith("namespace")).FirstOrDefault();
            if (string.IsNullOrWhiteSpace(entityNamespace))
            {
#>
// ERROR: Namespace Definition in Entity-File '<#= $"{entity}.cs" #>' was not found!
<#
    continue;
            }
            else
            {
                var seNamespaceParts = entityNamespace.Split('.');
                seNamespace = string.Join(".",
                    seNamespaceParts.Take(seNamespaceParts.Length - 1).Union(new[] {"StateEngines"}));
            }
        }

#>
//  <autogenerated>
//
//      This file was generated by T4 code generator 'StateEngineTamplate.tt'
//
//      Any changes made to this file manually will be lostnext time the file is regenerated.
//
//      As all classes are created as partial classes you can extend these classes by 
//      creating and adapting a matching partial class.
//
//</autogenerated>

using System;
using IG.SimpleStateWithActions.StateEngineShared;
using System.Collections.Generic;
using System.Linq.Expressions;
using IG.SimpleStateWithActions.StateEngineShared.Exceptions;
using <#= entityNamespace.Substring(9).Trim() #>;

<#= seNamespace #>
{
<#
        /// prepare values
        var transitionNames = 
            Transitions
                .Select(t => t.transitionOnSuccess)
                .Union(Transitions.Select(t => t.transitionOnFailed))
                .Where(t => !t.Equals("T_Error", StringComparison.InvariantCultureIgnoreCase)
                                && !string.IsNullOrWhiteSpace(t))
                .Distinct()
                .ToList();

#>
    public interface I<#= entity #>State : IState<I<#= entity #>State>
    {
<#
        foreach (var t in transitionNames)
        {
#>
        I<#= entity #>State <#= t #> { get; }
<#
        }
#>
    }

    public abstract class <#= entity #>State : State<I<#= entity #>State>, I<#= entity #>State
    {
<#
        foreach (var t in transitionNames)
        {
#>
        public virtual I<#= entity #>State <#= t #> => UndefinedTransition(nameof(<#= t #>));
<#
        }
#>
        public override I<#= entity #>State T_Error(I<#= entity #>State previousState, Expression<Func<I<#= entity #>State, I<#= entity #>State>> attemptedTransition, Exception exception)
            => new <#= entity #>States.T_Error() 
                {
                    PreviousState = previousState,
                    AttemptedTransition = attemptedTransition,
                    Exception = exception
                };
    }

    public class <#= entity #>States
    {
<#
        foreach (var s in states.Where(state => !state.Equals("T_Error")))
        {
#>
        public class <#= s #> : <#= entity #>State, IState<I<#= entity #>State>
        {
<#
            var stateTransitions = Transitions.Where(t => t.from == s).ToList();
            var generateTransitions =
                stateTransitions.Where(
                    t =>
                        !string.IsNullOrWhiteSpace(t.transitionOnSuccess) &&
                        !string.IsNullOrWhiteSpace(t.stateOnSuccess)).Select(
                            t => (transition: t.transitionOnSuccess, state: t.stateOnSuccess))
                    .Union(
                        stateTransitions.Where(
                            t =>
                                !string.IsNullOrWhiteSpace(t.transitionOnFailed) &&
                                !string.IsNullOrWhiteSpace(t.stateOnFailed)).Select(
                                    t => (transition: t.transitionOnFailed, state: t.stateOnFailed)));
        foreach (var t in generateTransitions)
        {
#>
            public override I<#= entity #>State <#= t.transition #> => new <#= entity #>States.<#= t.state #>();       
<#
        }
#>
        }

<#
        }
#>
        public class T_Error : <#= entity #>State, ITechnicalErrorState<I<#= entity #>State>, IState<I<#= entity #>State>
        {

<#
            var errStateTransitions = Transitions.Where(t => t.from == "T_Error").ToList();
            var errGenerateTransitions =
                errStateTransitions.Where(
                    t =>
                        !string.IsNullOrWhiteSpace(t.transitionOnSuccess) &&
                        !string.IsNullOrWhiteSpace(t.stateOnSuccess)).Select(
                            t => (transition: t.transitionOnSuccess, state: t.stateOnSuccess))
                    .Union(
                        errStateTransitions.Where(
                            t =>
                                !string.IsNullOrWhiteSpace(t.transitionOnFailed) &&
                                !string.IsNullOrWhiteSpace(t.stateOnFailed)).Select(
                                    t => (transition: t.transitionOnFailed, state: t.stateOnFailed)));
        foreach (var t in errGenerateTransitions)
        {
#>
            public override I<#= entity #>State <#= t.transition #> => new <#= entity #>States.<#= t.state #>();       
<#
        }
#>

            public T_Error() {}

            public void InitError(I<#= entity #>State previousState, Expression<Func<I<#= entity #>State, I<#= entity #>State>> attemptedTransition, Exception exception) 
            {
                PreviousState = previousState;
                AttemptedTransition = attemptedTransition;
                Exception = exception;
            }
            public I<#= entity #>State PreviousState { get; set; }
            public Expression<Func<I<#= entity #>State, I<#= entity #>State>> AttemptedTransition { get; set; }
            public Exception Exception { get; set; }
        }

    }

    /// <summary>
    /// 	RunStateController provides Actions that are to be executed on 
    /// 	state transitions. This allows modifications and interactions in
    /// 	and of the stated object when the state is about to change.
    /// </summary>
    public partial class <#= entity #>StateEngine : StateEngine<<#= entity #>, I<#= entity #>State>
    {

        public override List<Transition<<#= entity #>, I<#= entity #>State>> Transitions 
            => new List<Transition<<#= entity #>, I<#= entity #>State>>
            {
<#
        foreach (var t in Transitions)
        {
#>
                new Transition<<#= entity #>, I<#= entity #>State>(new <#= entity #>States.<#= t.from #>(), state => state.<#= t.transitionOnSuccess #>, <#= 
                        string.IsNullOrWhiteSpace(t.onTransitioning) ? "null" : t.onTransitioning #>, <#= 
                        string.IsNullOrWhiteSpace(t.transitionOnFailed) ? "null" : $"state => state.{t.transitionOnFailed}" #>,<#= 
                        string.IsNullOrWhiteSpace(t.onTransitionFailed) ? "null" : t.onTransitionFailed #>),
<#
        }
#>
            };

        // NOTE: if a constructor receiving specific dependencies is required, 
        //       defining the required constructor with all required dependencies 
        //       to handle the transitions, e. g. repositories, logger, etc.
        //       in the file <#= entity #>StateEngine.Partial.cs file
        //
        //       implement the following methods as partial methods in that partial 
        //       class as well in order to satisfy the MethodGroup-Calls in the
        //       transition list above
<#
        foreach (var t in Transitions)
        {
            if (!string.IsNullOrWhiteSpace(t.onTransitioning))
            {
#>
        private partial bool <#= t.onTransitioning#>(<#= entity #> <#= entity.ToLower() #>);
<#
            }
            if (!string.IsNullOrWhiteSpace(t.onTransitionFailed))
            {
#>
        private partial bool <#= t.onTransitionFailed#>(<#= entity #> <#= entity.ToLower() #>);
<#
            }
        }
#>
    }
} 
<#
        SaveFile(file.outDir, $"{entity}StateEngine.Generated.cs", this.GenerationEnvironment.ToString());
        this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
        string engineFile = Path.Combine(file.outDir, $"{entity}StateEngine.Partial.cs");
        if (File.Exists(engineFile)) continue;
#> 
//  <autogenerated>
//
//      This file was generated by T4 code generator 'StateEngineTamplate.tt'
//
//      Any changes made to this file manually will be PERSISTED.
//
//      This file will NOT be OVERWRITTEN at the next generation.
//      
//      Partial methods for new actions will have to be added manually.
//
//</autogenerated>
using System;
using IG.SimpleStateWithActions.StateEngineShared;
using System.Collections.Generic;
using System.Linq.Expressions;
using IG.SimpleStateWithActions.StateEngineShared.Exceptions;
using <#= entityNamespace.Substring(9).Trim() #>;

<#= seNamespace #>
{
    /// <summary>
    /// 	The RunStateController provides Actions that are to be executed on 
    /// 	state transitions. This allows modifications and interactions in
    /// 	and of the stated object when the state is about to change.
    /// </summary>
    public partial class <#= entity #>StateEngine
    {
        // NOTE: use the following constructor in this partial specific dependencies are required
        //       in order to handle transitions, e. g. repositories, logger, etc.
        public <#= entity #>StateEngine(/* add dependencies here */)
        {
        }

        // NOTE: implement the following partial methods in order to process the entities
        //       in accordance to the corresponding transitions
<#
        foreach (var t in Transitions)
        {
            if (!string.IsNullOrWhiteSpace(t.onTransitioning))
            {
#>
        private partial bool <#= t.onTransitioning#>(<#= entity #> <#= entity.ToLower() #>)
        {
            /* add logic here */
            return true;
        }
<#
            }
            if (!string.IsNullOrWhiteSpace(t.onTransitionFailed))
            {
#>
        private partial bool <#= t.onTransitionFailed#>(<#= entity #> <#= entity.ToLower() #>)
        {
            /* add logic here */
            return true;
        }
<#
            }
        }
#>
    }
}
<#
        SaveFile(file.outDir, engineFile, this.GenerationEnvironment.ToString());
        this.GenerationEnvironment.Remove(0, this.GenerationEnvironment.Length);
    }
#> 
<#+
    public void SaveFile(string folder, string fileName, string content)
    {
        string engineFile = Path.Combine(folder, fileName);
        using(FileStream fs = new FileStream(Path.Combine(folder, engineFile.Trim()), FileMode.Create))
        using (StreamWriter str = new StreamWriter(fs))
        {
            str.WriteLine(content);
            str.Flush();
        }
    }
#>
